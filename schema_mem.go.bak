package JSONParse

import (
	"fmt"
	"regexp"
)

func (js *JSONSchema) validMembers(doc *JSONNode, schema *JSONNode) {
	var item	*JSONNode
	var found	bool

	fmt.Println("    validate members")
	if item, found = schema.Find("properties"); !found {
		if item, found = schema.Find("$ref"); found {
			ref := item.FollowReference(js.schema.references)
			if ref != nil {
				item, found = ref.Find("properties")
			}
		} else {
			item = schema
		}
	} else {
		item = item.GetValue().(*JSONNode)
	}

	var addtlProps		*JSONNode
	allowAddtl := false

	fmt.Println("    check for additional props")
	if addtlProps, allowAddtl = schema.Find("additionalProperties"); allowAddtl {
		if addtlProps.GetType() == "member" {
			addtlProps = addtlProps.GetValue().(*JSONNode)
			// check for $ref
			if addtlItem, rfound := addtlProps.Find("$ref"); rfound {
				addtlProps = addtlItem.FollowReference(js.schema.references)
			}
		} else {
			allowAddtl = addtlProps.GetValue().(bool)
		}
	}

	if !found {
		fmt.Println("      props not found")
	}

	hasPatterns, patterns := js.allowPatterns(schema)
 
	doc.ResetIterate()

	for {
		var key		string
		var mem		*JSONNode
		var schemaObj	*JSONNode

		if key, mem = doc.GetNextMember(); mem == nil {
			fmt.Println("      end of mem list")
			break;
		}

		match := false
		fmt.Println("      validate member ", key)
		if item != nil {
			fmt.Println("      check member ", key," against base properties")
			if schemaMem, found := item.Find(key); found {
				schemaObj = schemaMem.GetValue().(*JSONNode)
				fmt.Println("      found Member: ", key)
				match = true
				// js.validMember(key, mem, schemaObj)
				// continue
			}
		}

		if !match && hasPatterns {
			fmt.Println("      check member ", key, " against patterns")
			for pattern, node := range patterns {
				regPattern := regexp.MustCompile(pattern)
				if match = regPattern.MatchString(key); match {
					fmt.Println("      matched pattern")
					schemaObj = node.GetValue().(*JSONNode)
					break;
				}
			}
		}

		if !match && (addtlProps != nil) {
			fmt.Println("      check member ", key," against additional properties")
			chkObj := mem.GetValue().(*JSONNode)
			js.validObject(chkObj, addtlProps)
		}

		if match {
			fmt.Println("      matched - call validMember")
			js.validMember(key, mem, schemaObj)
		} else if addtlProps != nil {
			fmt.Println("      member: ", key, " not found") 
		}
	}
}

func (js *JSONSchema) requiredMembers(mem *JSONNode, reqProps *JSONNode) {
	if reqProps == nil {
		return
	}

	reqArr := reqProps.GetValue().(*JSONNode)

	reqArr.ResetIterate()
	for {
		reqItem := reqArr.GetNextValue()
		if reqItem == nil {
			break
		}
		reqValue := reqItem.(string)

		if _, found := mem.Find(reqValue); !found {
			fmt.Println("      required member missing: ", reqValue)
		} else {
			fmt.Println("      required member found: ", reqValue)
		}
	}
}

func (js *JSONSchema) validMember(name string, mem *JSONNode, schemaMem *JSONNode) bool {
	// member type matches schema
	
	valid := true

	fmt.Println("      validate individual members: ", schemaMem.GetType(), mem.GetType());
	if schemaMem.GetType() == "object" {
		schemaMem.ResetIterate()
		for {
			key, item := schemaMem.GetNextMember()
			if item == nil {
				break;
			}

			if validator, found := keywords[key]; found {
				fmt.Println("      validate keyword ", key)
				valid = validator(mem, item)
			}

			if key == "$ref" {
				fmt.Println("      follow reference")
				ref := item.FollowReference(js.schema.references)
				if mem.GetType() != "string"  {
					js.validMembers(mem.GetValue().(*JSONNode), ref)
				}
			}
		}
//		validString(mem.Value.(string), schemaMem)
	} else if mem.GetType() == "NUMBER" {
//		validNumber(mem.Value.(string), schemaMem)
	} else if mem.GetType() == "object" {
		js.validObject(mem.GetValue().(*JSONNode), schemaMem.GetValue().(*JSONNode))
	} 
	if mem.GetType() == "array" {
		fmt.Println("      array ref ", schemaMem)
		js.validArray(mem.GetValue().(*JSONNode), schemaMem.GetValue().(*JSONNode))
	}
	
	return valid
}
